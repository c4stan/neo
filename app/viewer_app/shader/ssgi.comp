#version 460

#include "xs.glsl"
#include "common.glsl"

layout ( binding = 0, set = xs_shader_binding_set_per_draw_m ) uniform draw_uniforms_t {
    vec2 resolution_f32;
    uint hiz_mip_count;
} draw_uniforms;

layout ( binding = 1, set = xs_shader_binding_set_per_draw_m ) uniform texture2D tex_normal;
layout ( binding = 2, set = xs_shader_binding_set_per_draw_m ) uniform texture2D tex_base_color;
layout ( binding = 3, set = xs_shader_binding_set_per_draw_m ) uniform texture2D tex_lighting;
layout ( binding = 4, set = xs_shader_binding_set_per_draw_m ) uniform texture2D tex_hiz;

layout ( binding = 5, set = xs_shader_binding_set_per_draw_m, r11f_g11f_b10f ) uniform writeonly image2D img_color;

layout ( binding = 6, set = xs_shader_binding_set_per_draw_m ) uniform sampler sampler_point;

layout ( local_size_x = 8, local_size_y = 8, local_size_z = 1 ) in;

void main ( void ) {
    vec2 screen_uv = vec2 ( ( gl_GlobalInvocationID.xy + vec2 ( 0.5 ) ) / draw_uniforms.resolution_f32 );
    screen_uv = dejitter_uv ( screen_uv );

    // sample
    vec3 view_normal = texture ( sampler2D ( tex_normal, sampler_point ), screen_uv ).xyz * 2 - 1;
    float depth = textureLod ( sampler2D ( tex_hiz, sampler_point ), screen_uv, 0 ).x;
    vec3 base_color = texture ( sampler2D ( tex_base_color, sampler_point ), screen_uv ).xyz;

    // reconstruct position
    vec3 view_pos = view_from_depth ( screen_uv, depth );

    // init rng
    uint rng_state = rng_wang_init ( gl_GlobalInvocationID.xy );

#define RAY_COUNT 2

    // init accumulators
    float sample_distances[RAY_COUNT];
    vec3 sample_colors[RAY_COUNT];

    for ( uint ray_it = 0; ray_it < RAY_COUNT; ++ray_it ) {
        sample_colors[ray_it] = vec3 ( 0, 0, 0 );
        sample_distances[ray_it] = 1;
    }

    if ( depth < 1 ) {
        for ( uint ray_it = 0; ray_it < RAY_COUNT; ++ray_it ) {
            // sample hemisphere
            float ex = rng_wang ( rng_state );
            float ey = rng_wang ( rng_state );
            vec2 e2 = vec2 ( ex, ey );
            vec3 hemisphere_normal = sample_cosine_weighted_hemisphere_normal ( e2, view_normal );
            hemisphere_normal = normalize ( view_normal * 0.5f + hemisphere_normal ); // bias towards normal to reduce hiz self intersections

            // trace
            vec3 hit_screen_pos;
            float hit_depth;

            if ( trace_screen_space_ray ( hit_screen_pos, hit_depth, view_pos, hemisphere_normal, tex_hiz, draw_uniforms.hiz_mip_count, sampler_point, 50 ) ) {
                vec3 hit_color = texture ( sampler2D ( tex_lighting, sampler_point ), hit_screen_pos.xy ).xyz;
                float hit_distance = distance ( view_pos, view_from_depth ( hit_screen_pos.xy, hit_depth ) );
                sample_colors[ray_it] = hit_color *  dot ( view_normal, hemisphere_normal );
                sample_distances[ray_it] = hit_distance;
            }
        }
    }

    vec3 sample_color = vec3 ( 0, 0, 0 );

    for ( uint ray_it = 0; ray_it < RAY_COUNT; ++ray_it ) {
        float attenuation = 1.0 / ( sample_distances[ray_it] + 1 );
        //float occlusion = min ( 1.0, sample_distances[ray_it] );
        sample_color += sample_colors[ray_it] * base_color * attenuation;// * occlusion;// * attenuation * attenuation;
    }

    sample_color /= float ( RAY_COUNT );

    //out_color = vec4 ( sample_color, 1 );
    imageStore ( img_color, ivec2 ( gl_GlobalInvocationID.xy ), vec4 ( sample_color, 1 ) );
}
