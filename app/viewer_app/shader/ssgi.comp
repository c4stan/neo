#version 460

#include "xs.glsl"
#include "common.glsl"

layout ( binding = 0, set = xs_shader_binding_set_dispatch_m ) uniform draw_uniforms_t {
    vec2 resolution_f32;
    uint hiz_mip_count;
} draw_uniforms;

layout ( binding = 1, set = xs_shader_binding_set_dispatch_m ) uniform texture2D tex_normal;
layout ( binding = 2, set = xs_shader_binding_set_dispatch_m ) uniform texture2D tex_base_color;
layout ( binding = 3, set = xs_shader_binding_set_dispatch_m ) uniform texture2D tex_lighting;
layout ( binding = 4, set = xs_shader_binding_set_dispatch_m ) uniform texture2D tex_hiz;

layout ( binding = 5, set = xs_shader_binding_set_dispatch_m, r11f_g11f_b10f ) uniform writeonly image2D img_color;

layout ( binding = 6, set = xs_shader_binding_set_dispatch_m ) uniform sampler sampler_linear;

layout ( local_size_x = 8, local_size_y = 8, local_size_z = 1 ) in;

// Fast PRNG (from "Hash without Sine" by David Hoskins)
uint hash(uint seed) {
    seed = (seed ^ 61u) ^ (seed >> 16u);
    seed *= 9u;
    seed = seed ^ (seed >> 4u);
    seed *= 0x27d4eb2du;
    seed = seed ^ (seed >> 15u);
    return seed;
}

float randomFloat(inout uint state) {
    return float(hash(state)) / 4294967296.0; // Normalize to [0, 1]
}

// Generate a random seed based on pixel and frame
uint getRandomSeed(vec2 uv, vec2 resolution, float time) {
    uint seed = uint(uv.x * resolution.x + uv.y) * uint(resolution.x);
    seed += uint(time); // Temporal variation
    return seed;
}

void main ( void ) {
    vec2 screen_uv = vec2 ( ( gl_GlobalInvocationID.xy + vec2 ( 0.5 ) ) / draw_uniforms.resolution_f32 );
    screen_uv = dejitter_uv ( screen_uv );

    // sample
    vec3 view_normal = texture ( sampler2D ( tex_normal, sampler_linear ), screen_uv ).xyz * 2 - 1;
    float depth = textureLod ( sampler2D ( tex_hiz, sampler_linear ), screen_uv, 0 ).x;
    vec3 base_color = texture ( sampler2D ( tex_base_color, sampler_linear ), screen_uv ).xyz;

    // reconstruct position
    vec3 view_pos = view_from_depth ( screen_uv, depth );

    // init rng
    uint rng_state = rng_wang_init ( gl_GlobalInvocationID.xy );

#define RAY_COUNT 1

    // init accumulators
    float sample_distances[RAY_COUNT];
    vec3 sample_colors[RAY_COUNT];

    for ( uint ray_it = 0; ray_it < RAY_COUNT; ++ray_it ) {
        sample_colors[ray_it] = vec3 ( 0, 0, 0 );
        sample_distances[ray_it] = 1;
    }

    float ex = rng_wang ( rng_state );
    float ey = rng_wang ( rng_state );
    uint seed = getRandomSeed(gl_GlobalInvocationID.xy, draw_uniforms.resolution_f32, frame_uniforms.frame_id );
    //ex = randomFloat ( seed );
    //ey = randomFloat ( seed );

    float incoming_radiance;
    vec3 hemisphere_normal;
    vec3 hit_normal;

    if ( depth < 1 ) {
        for ( uint ray_it = 0; ray_it < RAY_COUNT; ++ray_it ) {
            // sample hemisphere
            vec2 e2 = vec2 ( ex, ey );
            hemisphere_normal = sample_cosine_weighted_hemisphere_normal ( e2, view_normal );
            hemisphere_normal = normalize ( view_normal * 0.5f + hemisphere_normal ); // bias towards normal to reduce hiz self intersections

            // trace
            vec3 hit_screen_pos;
            float hit_depth;
            bool hit;

            hit = trace_screen_space_ray ( hit_screen_pos, hit_depth, view_pos, hemisphere_normal, tex_hiz, draw_uniforms.hiz_mip_count, sampler_linear, 50 ); 

            if ( hit ) {
                vec3 hit_color = texture ( sampler2D ( tex_base_color, sampler_linear ), hit_screen_pos.xy ).xyz;
                hit_normal = normalize ( texture ( sampler2D ( tex_normal, sampler_linear ), hit_screen_pos.xy ).xyz * 2 - 1 );
                vec3 hit_view_pos = view_from_depth ( hit_screen_pos.xy, hit_depth );
                float hit_distance = distance ( view_pos, hit_view_pos );
                incoming_radiance = clamp ( dot ( hit_normal, -hemisphere_normal ), 0, 1 ); // Approximate with a simple NdotL...
                sample_colors[ray_it] = hit_color *  dot ( view_normal, hemisphere_normal ) * incoming_radiance;
                sample_distances[ray_it] = hit_distance;
            }
        }
    }

    vec3 sample_color = vec3 ( 0, 0, 0 );

    for ( uint ray_it = 0; ray_it < RAY_COUNT; ++ray_it ) {
        float d = sample_distances[ray_it];
        float attenuation = 1.0 / ( d * d + 5 );
        //float occlusion = min ( 1.0, sample_distances[ray_it] );
        sample_color += sample_colors[ray_it] * base_color * attenuation / 3.1415;// * occlusion;// * attenuation * attenuation;
    }

    sample_color /= float ( RAY_COUNT );

    //out_color = vec4 ( sample_color, 1 );
    imageStore ( img_color, ivec2 ( gl_GlobalInvocationID.xy ), vec4 ( sample_color, 1 ) );
    //imageStore ( img_color, ivec2 ( gl_GlobalInvocationID.xy ), vec4 ( hit_normal * 0.5 + vec3(0.5), 1 ) );
}
