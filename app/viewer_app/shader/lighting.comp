#version 450

#include "common.glsl"
#include "lighting_common.glsl"

#extension GL_EXT_debug_printf : enable

layout ( binding = 0, set = xs_shader_binding_set_dispatch_m ) uniform uniform_buffer_t {
    uvec3 grid_size;
    float z_scale;
    float z_bias;
    uint shadow_size;
} uniform_buffer;

layout ( binding = 1, set = xs_shader_binding_set_dispatch_m ) buffer readonly light_buffer_t {
    uint light_count;
    uint _pad0[3];
    light_t lights[];
} light_buffer;

layout ( binding = 2, set = xs_shader_binding_set_dispatch_m ) buffer readonly light_list_buffer_t {
    uint global_offset_accumulator;
    uint list[];
} light_list_buffer;

layout ( binding = 3, set = xs_shader_binding_set_dispatch_m ) buffer readonly light_grid_buffer_t {
    light_grid_t grid[];
} light_grid_buffer;

layout ( binding = 4, set = xs_shader_binding_set_dispatch_m ) uniform texture2D tex_color;
layout ( binding = 5, set = xs_shader_binding_set_dispatch_m ) uniform texture2D tex_normal;
layout ( binding = 6, set = xs_shader_binding_set_dispatch_m ) uniform texture2D tex_depth;
layout ( binding = 7, set = xs_shader_binding_set_dispatch_m ) uniform texture2D tex_shadows;

layout ( binding = 8, set = xs_shader_binding_set_dispatch_m, r11f_g11f_b10f ) uniform writeonly image2D img_color;

layout ( binding = 9, set = xs_shader_binding_set_dispatch_m ) uniform sampler sampler_linear;

layout ( local_size_x = 8, local_size_y = 8, local_size_z = 1 ) in;

float shadow_gather ( vec2 uv, float z ) {
#if 1
    vec4 depths = textureGather ( sampler2D ( tex_shadows, sampler_linear ), uv );
    vec4 compare = vec4 ( z );
    vec4 test = step ( depths, compare );
    return dot ( test, vec4 ( 1 ) );
#else
    float shadow_depth = texture ( sampler2D ( tex_shadows, sampler_linear ), uv ).x;
    float shadow_contribution = z > shadow_depth ? 1.f : 0.f;
    return shadow_contribution;
#endif
}

void main ( void ) {
    vec2 screen_uv = vec2 ( ( gl_GlobalInvocationID.xy + vec2 ( 0.5 ) ) / frame_cbuffer.resolution_f32 );

    vec3 view_normal = texture ( sampler2D ( tex_normal, sampler_linear ), screen_uv ).xyz * 2 - 1;
    vec3 base_color = texture ( sampler2D ( tex_color, sampler_linear ), screen_uv ).xyz;
    float depth = texture ( sampler2D ( tex_depth, sampler_linear ), screen_uv ).x;

    vec3 view_geo_pos = view_from_depth ( screen_uv, depth );
    // Normal Offset shadows, helps with acne
    // https://digitalrune.github.io/DigitalRune-Documentation/html/3f4d959e-9c98-4a97-8d85-7a73c26145d7.htm
    // https://mynameismjp.wordpress.com/2013/09/10/shadow-maps/
    // https://c0de517e.blogspot.com/2011/05/shadowmap-bias-notes.html
    // https://ndotl.wordpress.com/2014/12/19/notes-on-shadow-bias/
    view_geo_pos += view_normal * 0.03;
    vec4 world_geo_pos = frame_cbuffer.world_from_view * vec4 ( view_geo_pos, 1.f );

    vec3 irradiance = vec3 ( 0, 0, 0 );

    uvec3 cluster_3d_idx;
    // TODO precompute
    //cluster_3d_idx.z = uint ( max ( log2 ( linearize_depth ( depth ) ) * uniform_buffer.z_scale + uniform_buffer.z_bias, 0 ) );
    cluster_3d_idx.z = uint ( max ( log ( linearize_depth ( depth ) ) 
        * ( uniform_buffer.grid_size.z / log ( frame_cbuffer.z_far / frame_cbuffer.z_near ) )
        + ( - ( uniform_buffer.grid_size.z * log ( frame_cbuffer.z_near ) ) / log ( frame_cbuffer.z_far / frame_cbuffer.z_near ) )
        , 0 ) );
    cluster_3d_idx.xy = uvec2 ( ( gl_GlobalInvocationID.xy + vec2 ( 0.5 ) ) / frame_cbuffer.resolution_f32 * uniform_buffer.grid_size.xy );

    uint cluster_idx = cluster_3d_idx.x + uniform_buffer.grid_size.x * cluster_3d_idx.y + ( uniform_buffer.grid_size.x * uniform_buffer.grid_size.y ) * cluster_3d_idx.z;

    light_grid_t grid = light_grid_buffer.grid[cluster_idx];
    for ( uint i = 0; i < grid.count; ++i ) {
        uint list_idx = grid.offset + i;
        uint light_idx = light_list_buffer.list[list_idx];
        light_t light = light_buffer.lights[light_idx];

        vec3 world_light_pos = light.pos;
        float light_emissive = light.emissive;
        vec3 light_color = light.color;

        // TODO refactor screen_from_view to take in a proj_from_view matrix and use that
        vec4 shadow_proj = light.view_from_world * world_geo_pos;
        shadow_proj = light.proj_from_view * shadow_proj;
        shadow_proj /= shadow_proj.w;
        vec3 shadow_screen = vec3 ( shadow_proj.xy * vec2 ( 0.5, -0.5 ) + 0.5, shadow_proj.z );
        vec2 shadow_texel = light.shadow_tile.xy + shadow_screen.xy * light.shadow_tile.z;

        float shadow = 0;
        int pcf_radius = 2;

        if ( any ( greaterThan ( shadow_screen, vec3(1.0) ) ) || any ( lessThan ( shadow_screen, vec3(0.0) ) ) ) {
            continue;
        }

        float texel_size = ( 1.f / uniform_buffer.shadow_size );

#if 0
        for ( int dx = -pcf_radius; dx <= pcf_radius; dx += 1 ) {
            for ( int dy = -pcf_radius; dy <= pcf_radius; dy += 1 ) {
                vec2 shadow_uv = shadow_texel + vec2 ( dx, dy );
                //shadow_uv = shadow_uv - fract ( shadow_uv );
                //shadow_uv += vec2 ( 0.5 );
                shadow_uv = clamp ( shadow_uv, light.shadow_tile.xy + vec2 ( 0.5 ), light.shadow_tile.xy + vec2 ( light.shadow_tile.z, light.shadow_tile.z ) - vec2 ( 0.5 ) );
                shadow_uv *= ( 1.f / uniform_buffer.shadow_size );
                float shadow_depth = texture ( sampler2D ( tex_shadows, sampler_linear ), shadow_uv ).x;

                float shadow_bias = 0.0001;
                float shadow_contribution = shadow_proj.z - shadow_bias > shadow_depth ? 1.f : 0.f;

                if ( shadow_screen.z > 1.f ) {
                    shadow_contribution = 0;
                }

                shadow += shadow_contribution;
            }
        }

        shadow /= ( pcf_radius * 2 + 1 ) * ( pcf_radius * 2 + 1 );

#else
        float shadow_bias = 0.00001;

        vec2 shadow_uv = shadow_texel + vec2 (-1.0, -1.0 );
        shadow_uv = clamp ( shadow_uv, light.shadow_tile.xy + vec2 ( 1 ), light.shadow_tile.xy + vec2 ( light.shadow_tile.z, light.shadow_tile.z ) - vec2 ( 1 ) );
        shadow_uv *= texel_size;
        shadow += shadow_gather ( shadow_uv, shadow_proj.z - shadow_bias );
        
        shadow_uv = ( shadow_texel + vec2 ( +1.0, -1.0 ) );
        shadow_uv = clamp ( shadow_uv, light.shadow_tile.xy + vec2 ( 1 ), light.shadow_tile.xy + vec2 ( light.shadow_tile.z, light.shadow_tile.z ) - vec2 ( 1 ) );
        shadow_uv *= texel_size;
        shadow += shadow_gather ( shadow_uv, shadow_proj.z - shadow_bias );
        
        shadow_uv = ( shadow_texel + vec2 ( -1.0, +1.0 ) );
        shadow_uv = clamp ( shadow_uv, light.shadow_tile.xy + vec2 ( 1 ), light.shadow_tile.xy + vec2 ( light.shadow_tile.z, light.shadow_tile.z ) - vec2 ( 1 ) );
        shadow_uv *= texel_size;
        shadow += shadow_gather ( shadow_uv, shadow_proj.z - shadow_bias );
        
        shadow_uv = ( shadow_texel + vec2 ( +1.0, +1.0 ) );
        shadow_uv = clamp ( shadow_uv, light.shadow_tile.xy + vec2 ( 1 ), light.shadow_tile.xy + vec2 ( light.shadow_tile.z, light.shadow_tile.z ) - vec2 ( 1 ) );
        shadow_uv *= texel_size;
        shadow += shadow_gather ( shadow_uv, shadow_proj.z - shadow_bias );

        shadow /= 16.0;
#endif


        float light_visibility = ( 1.f - shadow );

        vec3 view_light_pos = ( frame_cbuffer.view_from_world * vec4 ( world_light_pos, 1 ) ).xyz;
        vec3 view_light_dir = normalize ( view_light_pos - view_geo_pos );
        float nl = clamp ( dot ( view_light_dir, view_normal ), 0, 1 );
        float d = distance ( view_geo_pos, view_light_pos );

        irradiance += light_visibility * light_emissive * light_color * base_color * nl / ( d * d );
    }

    float ambient_emissive = light_buffer.light_count > 0 ? 0 : 0.2;
    vec3 ambient_color = vec3 ( 1, 1, 1 );
    vec3 direct = irradiance + ambient_emissive * ambient_color * base_color;

    imageStore ( img_color, ivec2 ( gl_GlobalInvocationID.xy ), vec4 ( direct, 1 ) );
}
