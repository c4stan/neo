#version 460
#extension GL_NV_ray_tracing : require

#include <xs.glsl>

#include "common.glsl"

layout ( location = 0 ) rayPayloadNV ray_payload_t          ray_payload;
layout ( location = 1 ) rayPayloadNV shadow_ray_payload_t   shadow_ray_payload;

layout ( binding = 0, set = xs_shader_binding_set_dispatch_m ) uniform accelerationStructureNV scene;
layout ( binding = 1, set = xs_shader_binding_set_dispatch_m, rgba32f ) uniform image2D img_color;

void trace_ray ( vec3 pos, vec3 dir ) {
    const uint trace_flags = gl_RayFlagsOpaqueEXT;
    const uint cull_mask = 0xff;
    const uint sbt_hit_idx = 0;
    const uint sbt_stride = 0;
    const uint sbt_miss_idx = 0;
    const float t_min = 0.001;
    const float t_max = 10000.0;
    const int payload_id = 0;
    traceNV (
        scene,
        trace_flags,
        cull_mask,
        sbt_hit_idx,
        sbt_stride,
        sbt_miss_idx,
        pos,
        t_min,
        dir,
        t_max,
        payload_id
    );
}

void trace_shadow_ray ( vec3 pos, vec3 dir ) {
    const uint trace_flags = gl_RayFlagsOpaqueEXT | gl_RayFlagsTerminateOnFirstHitNV;
    const uint cull_mask = 0xff;
    const uint sbt_hit_idx = 1;
    const uint sbt_stride = 0;
    const uint sbt_miss_idx = 1;
    const float t_min = 0.001;
    const float t_max = 10000.0;
    const int payload_id = 1;
    traceNV (
        scene,
        trace_flags,
        cull_mask,
        sbt_hit_idx,
        sbt_stride,
        sbt_miss_idx,
        pos,
        t_min,
        dir,
        t_max,
        payload_id
    );
}

void main ( void ) {
    const vec2 pixel_center = vec2 ( gl_LaunchIDNV.xy ) + vec2 ( 0.5 );
    const vec2 uv = pixel_center / vec2 ( gl_LaunchSizeNV.xy );
    const vec2 ndc = uv * 2.0 - 1.0;

    vec3 origin = ( frame_uniforms.world_from_view * vec4 ( 0, 0, 0, 1 ) ).xyz;
    const vec4 target = frame_uniforms.view_from_proj * vec4 ( ndc.x, ndc.y, 1, 1 );
    vec3 direction = ( frame_uniforms.world_from_view * vec4 ( normalize ( target.xyz ), 0 ) ).xyz;

    vec3 throughput = vec3(1);
    vec3 radiance = vec3(0);

    uint rng_state = rng_wang_init ( pixel_center );

    const uint bounces = 8;
    for ( uint i = 0; i < bounces; ++i ) {
        trace_ray ( origin, direction );

        if ( ray_payload.distance < 0 ) {
            throughput *= ray_payload.color;
            radiance += throughput;
            break;
        }

        radiance += ray_payload.color * ray_payload.emissive * throughput;
        throughput *= ray_payload.color;
        //throughput *= dot ( ray_payload.normal, -direction );

        origin = origin + direction * ray_payload.distance + ray_payload.normal * 0.001f;
        direction = sample_cosine_weighted_hemisphere_normal ( vec2 ( rng_wang ( rng_state ), rng_wang ( rng_state ) ), ray_payload.normal );

        //trace_shadow_ray();
    }

    imageStore ( img_color, ivec2 ( gl_LaunchIDNV.x, gl_LaunchSizeNV.y - gl_LaunchIDNV.y ), vec4 ( radiance, 1 ) );
}
